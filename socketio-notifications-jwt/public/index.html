<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Socket.IO Notifications + JWT + MongoDB + Refresh</title>
</head>
<body>
  <h2>Notifications Demo (Refresh Tokens)</h2>

  <div>
    <label>Username: <input id="username" /></label>
    <button id="btnLogin">Get Token & Connect</button>
    <button id="btnLogout">Logout</button>
    <button id="btnEnablePush">Enable Push</button>
  </div>

  <div id="clientUI" style="display:none;">
    <p>Connected as: <span id="who"></span></p>
    <button id="btnGetMissed">Reload Missed</button>
    <button id="btnMarkAll">Mark All Read (REST)</button>
    <ul id="notifs"></ul>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    let socket, accessToken, username;

    const $ = (id) => document.getElementById(id);

    async function api(path, options = {}, retryOn401 = true) {
      const res = await fetch(path, {
        ...options,
        headers: {
          ...(options.headers || {}),
          'Content-Type': 'application/json',
          ...(accessToken ? { Authorization: 'Bearer ' + accessToken } : {})
        },
        credentials: 'include' // to include cookies (for refresh token)
      });

      if (res.status === 401 && retryOn401) {
        // try to refresh the token
        // if it fails, the user should login again
        // if it succeeds, retry the original request once
        // this is a simplified example, in production you might want to handle this differently
        // e.g. show a login modal, redirect to login page, etc.
        const ok = await tryRefresh(); 
        if (ok) {
          // retry once
          return api(path, options, false); 
        }
      }
      return res;
    }

    // Try to refresh the access token using the refresh token
    // This will send a request to the server to get a new access token
    // If successful, it will update the accessToken variable
    // If it fails, it will return false
    async function tryRefresh() {
      const res = await fetch('/refresh', { method: 'POST', credentials: 'include' });
      if (res.ok) {
        const data = await res.json();
        accessToken = data.token;
        // reconnect the socket with the new token
        await reconnectSocket();
        return true;
      }
      return false;
    }


    // Reconnect the socket with the current access token
    // This will disconnect the current socket (if any) and create a new one
    // It will also set up the necessary event listeners for notifications
    // If the socket connection fails due to an invalid token, it will try to refresh the token
    // If the refresh fails, it will alert the user to login again
    // This is a simplified example, in production you might want to handle this differently
    // e.g. show a login modal, redirect to login page, etc.
    // In production, consider adding more error handling, logging, or additional features
    // such as reconnect attempts, exponential backoff, etc.
    async function reconnectSocket() {
      if (socket) {
        try { socket.disconnect(); } catch(e) {}
      }
      socket = io({ auth: { token: accessToken } });

      socket.on('connect_error', async (err) => {
        console.warn('socket connect_error:', err.message);
        if (/invalid token/i.test(err.message)) {
          const ok = await tryRefresh();
          if (!ok) alert('Please login again');
        }
      });

      socket.on('notification', (n) => addNotif(n, false));
      socket.on('missed', (list) => list.forEach((n) => addNotif(n, true)));
      socket.on('markedRead', (ids) => {
        ids.forEach((id) => {
          const li = document.querySelector(`li[data-id="${id}"]`);
          if (li) li.style.opacity = 0.5;
        });
      });
    }

    $('btnLogin').onclick = async () => {
      username = $('username').value.trim();
      if (!username) return alert('enter username');

      // Login to get the access token
      // This will send a request to the server to get a new access token
      // The server will validate the username and return a new access token
      // If the login fails, it will alert the user
      const res = await fetch('/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ username })
      });

      if (!res.ok) return alert('login failed');
      const data = await res.json();
      accessToken = data.token;

      // Reconnect the socket with the new access token
      // This will disconnect the current socket (if any) and create a new one
      // It will also set up the necessary event listeners for notifications
      // If the socket connection fails due to an invalid token, it will try to refresh the token
      // If the refresh fails, it will alert the user to login again
      await reconnectSocket();

      $('clientUI').style.display = 'block';
      $('who').textContent = username;
    };

    // Logout the user
    // This will send a request to the server to revoke the current refresh token
    // It will also clear the access token and disconnect the socket
    // If the logout fails, it will alert the user
    // This is important to prevent further access using the old token
    $('btnLogout').onclick = async () => {
      await fetch('/logout', { method: 'POST', credentials: 'include' });
      accessToken = null;
      if (socket) socket.disconnect();
      $('clientUI').style.display = 'none';
      $('notifs').innerHTML = '';
      alert('Logged out');
    };

    $('btnGetMissed').onclick = () => {
      if (!socket) return;
      socket.emit('getMissed');
    };

    $('btnMarkAll').onclick = async () => {
      const res = await api('/notifications/mark-all-read', { method: 'POST' });
      if (res.ok) {
        document.querySelectorAll('#notifs li').forEach(li => li.style.opacity = 0.5);
      } else if (res.status === 401) {
        alert('Unauthorized. Please login again.');
      }
    };

     $('btnEnablePush').onclick = async () => {
      if (!accessToken) return alert('Login first');

      // 1) request permission for notifications
      const perm = await Notification.requestPermission();
      if (perm !== 'granted') {
        return alert('Notifications permission denied');
      }

      // 2) register the service worker
      const swReg = await navigator.serviceWorker.register('/sw.js');

      // 3) get the public VAPID key from the server
      // This key is used to encrypt the push messages sent by the server
      const keyRes = await fetch('/push/public-key');
      const { key } = await keyRes.json();

      // 4) convert the Base64URL public key to Uint8Array
      // This is required by the Push API to subscribe to push notifications
      const appServerKey = urlBase64ToUint8Array(key);

      // 5) subscribe to push notifications
      // This will create a subscription object that contains the endpoint and keys
      // The endpoint is the URL where the push messages will be sent
      // The keys are used to encrypt the messages
      // The userVisibleOnly option is set to true to indicate that the user should see notifications
      const subscription = await swReg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: appServerKey
      });

      // 6) send the subscription to the server
      // This will save the subscription in the database and associate it with the user
      // The server will use this subscription to send push messages to the user
      // If the subscription is already saved, it will update it
      // If the subscription is new, it will create a new entry in the database
      // The server will also send a confirmation message to the client
      // If the request fails, it will alert the user
      // This is important to ensure that the user can receive push notifications
      const res = await api('/push/subscribe', {
        method: 'POST',
        body: JSON.stringify(subscription)
      });

      if (res.ok) {
        alert('Push enabled!');
      } else {
        alert('Failed to enable push');
      }
    };

    // helper: Base64URL → Uint8Array
    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const raw = atob(base64);
      const output = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; ++i) {
        output[i] = raw.charCodeAt(i);
      }
      return output;
    }

    
    function addNotif(n, isMissed) {
      const li = document.createElement('li');
      li.dataset.id = n.id || '';
      const when = n.createdAt ? new Date(n.createdAt).toLocaleString() : '';
      const missedTag = isMissed ? '[MISSED] ' : '';
      li.textContent = `${missedTag}${n.title} — ${n.body || ''} ${when ? '(' + when + ')' : ''}`;

      li.onclick = async () => {
        if (!n.id) return;
        if (!socket) return;
        socket.emit('markRead', [n.id]);
      };

      if (n.read) li.style.opacity = 0.5;
      $('notifs').prepend(li);
    }
  </script>
</body>
</html>
